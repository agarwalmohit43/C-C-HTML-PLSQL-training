equi join or natural
1. select emp.ename,dept.dname,emp.deptno from emp,dept where emp.deptno=dept.deptno;
2. select ename,dname from emp natural JOIN dept;
non equi join
 select ename,sal,grade from emp,salgrade where sal between losal and hisal;
 
outer join
right-select emp.ename,dept.dname,emp.deptno from emp,dept where emp.deptno(+)=dept.deptno;
left-select emp.ename,dept.dname,emp.deptno from emp,dept where emp.deptno=dept.deptno(+);

self join
  select e1.ename,e2.ename as manager from emp e1,emp e2 where e1.mgr=e2.empno;

cross join
 select ename,dname from emp CROSS JOIN dept;

using clause:
1.select ename,dname from emp  JOIN dept using(deptno,deptno);

on clause:
1.select ename,dname from emp  JOIN dept on(emp.deptno=dept.deptno) and dept.dname='SALES';

right join
select ename,dname from emp  right JOIN dept on(emp.deptno=dept.deptno);

left join
select ename,dname from emp  leftk JOIN dept on(emp.deptno=dept.deptno);

full outer join
select ename,dname from emp  full outer JOIN dept on(emp.deptno=dept.deptno);

DAY 3:
SUBQUERY
1.SELECT DNAME FROM DEPT WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='MILLER');

CORELATED SUBQUERY
1.SELECT E1.ENAME FROM EMP E1 WHERE E1.SAL>(SELECT E2.SAL FROM EMP E2 WHERE E1.MGR=E2.EMPNO);

MULTIPLE SUBQUERY
1.SELECT ENAME,SAL FROM EMP WHERE SAL<ALL(SELECT SAL FROM EMP WHERE ENAME='MILLER' OR ENAME='JONES');
2.SELECT ENAME,SAL FROM EMP WHERE SAL<ANY(SELECT SAL FROM EMP WHERE ENAME='MILLER' OR ENAME='JONES');
3.SELECT ENAME FROM EMP WHERE DEPTNO IN((SELECT DEPTNO FROM EMP WHERE ENAME='MILLER' OR ENAME='FORD'));
4.SELECT ENAME FROM EMP WHERE DEPTNO NOT IN((SELECT DEPTNO FROM EMP WHERE ENAME='MILLER' OR ENAME='FORD'));

EXISTS/NOT EXISTS
1.SELECT ENAME FROM EMP WHERE NOT EXISTS(SELECT MGR FROM EMP WHERE ENAME='KING');
2.SELECT ENAME FROM EMP WHERE EXISTS(SELECT MGR FROM EMP WHERE ENAME='KING');
3. SELECT ENAME FROM EMP e1 WHERE EXISTS(SELECT MGR FROM EMP E2 WHERE E1.MGR=E2.EMPNO);

CONNECT BY START WITH CLAUSE
1.SELECT ENAME,EMPNO,MGR FROM EMP CONNECT BY PRIOR EMPNO=MGR START WITH ENAME='KING';
2.SELECT ENAME,EMPNO,MGR FROM EMP CONNECT BY PRIOR EMPNO=MGR START WITH ENAME='BLAKE';

TABLE CREATION:
1.CREATE TABLE MY_EMP(EMP_NO NUMBER(5),EMP_NAME VARCHAR2(20),EMP_EMAILID VARCHAR2(20),EMP_MOBILE NUMBER(10));

DATA INSERTION:
1.
INSERT INTO MY_EMP VALUES(1,'MOHIT','AGARWALMOHIT43@GMAIL',8981871984);
INSERT INTO MY_EMP VALUES(2,'AMIT','ANIT@GMAIL',8981871856);
INSERT INTO MY_EMP VALUES(3,'ANIMESH','ANIMESH@GMAIL',89818715656);
INSERT INTO MY_EMP VALUES(4,'KISS WHORE','KISHOR@GMAIL',1234569874);
INSERT INTO MY_EMP VALUES(5,'RAKESH','RAKESH@GMAIL',9923701001);
INSERT INTO MY_EMP VALUES(6,'NITIN','NITIN@GMAIL',9823333309);

2.INSERT INTO MY_EMP VALUES(&NO,'&NAME','&EMAIL',&NUM)
SQL> INSERT INTO MY_EMP VALUES(&NO,'&NAME','&EMAIL',&NUM);
Enter value for no: 7
Enter value for name: ILU
Enter value for email: ILU@GMAIL.COM
Enter value for num: 9051144448
old   1: INSERT INTO MY_EMP VALUES(&NO,'&NAME','&EMAIL',&NUM)
new   1: INSERT INTO MY_EMP VALUES(7,'ILU','ILU@GMAIL.COM',9051144448)

CREATING TABLE WITH CONSTRAINTS
1.CREATE TABLE MY_EMP(EMP_NO NUMBER(5) CONSTRAINT MY_EMP_PK PRIMARY KEY,EMP_NAME VARCHAR2(20) NOT NULL,EMP_EMAILID VARCHAR2(20) CONSTRAINT MY_EMP_UNQ UNIQUE NOT NULL,EMP_STATE VARCHAR2(3) DEFAULT('MH'),EMP_MOBILE NUMBER(10)CHECK(EMP_MOBILE>0));

2.INSERT INTO MY_EMP VALUES(1,'RAKESH','RAKESH@GMAIL.COM','UP',9988776655);

3.CREATE TABLE EMP_DUMMY AS SELECT * FROM MY_EMP; - FROM EXISTING TABLE.

ALTER TABLE
1. ALTER TABLE MY_FOO RENAME FOO_NUM TO FOO_NO;
2. ALTER TABLE MY_FOO ADD(FOO_MAIL VARCHAR2(20));
3. ALTER TABLE MY_FOO MODIFY(FOO_MAIL VARCHAR2(40));
4. ALTER TABLE MY_FOO ADD CONSTRAINT MY_FOO_UNQ UNIQUE(FOO_MAIL);
5. ALTER TABLE MY_FOO DROP COLUMN FOO_MAIL;


CONSTRAINT CHECK
1. SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME='MY_EMP';

DELETE GOES IN RECYCLEBIN
1.DELETE FROM MY_EMP;

ROLLBACK 
1. ROLLBACK;

TRUNCATE DELETE THE DATA PERMANENT
1. TRUNCATE TABLE MY_EMP;

DROP DELETE TABLE AND DATA BOTH
1. DROP TABLE MY_EMP;

SHOW TABLES AND OBJECT
1. SELECT TABLE_NAME FROM USER_TABLES;
2. SELECT OBJECT_NAME FROM USER_OBJECTS; 

BITMAP INDEX
1. CREATE BITMAP INDEX MY_BITMAP ON EMP(SAL);
2. DROP INDEX MY_BITMAP;

SYNONYM IS ALIAS
1. CREATE SYNONYM MY FOR EMP;
   SELECT * FROM MY;
2. DROP SYNONYM MY;
   
SEQUENCE 
1. CREATE SEQUENCE EMPNO_SEQ INCREMENT BY 1 MAXVALUE 10 NOCYCLE;
2. SELECT EMPNO_SEQ.NEXTVAL FROM DUAL;
3. DROP SEQUENCE EMPNO_SEQ;

DAY 4:

VIEW IS A LOGICAL TABLE THAT IS CREATED FROM THE PHYSICAL TABLE
1. CREATE VIEW MY_V1 AS SELECT EMPNO,ENAME,SAL FROM EMP;
2. SELECT * FROM MY_V1;
*DELETE MADE AT LOGICAL TABLE REFLECTS CHANGES IN PHYSICAL TABLE.
3. DELETE FROM MY_V1 WHERE EMPNO=7369;
*WITH CHECK OPTION
4. CREATE VIEW MY_V22 AS SELECT ENAME,DEPTNO,SAL FROM EMP WHERE DEPTNO=10 WITH CHECK OPTION CONSTRAINT CSN;

UNION,INTERSECTION,MINUS

MERGE 
1. MERGE INTO EMPS_DUAL USING EMP ON (EMP.EMPNO=EMPS_DUAL.EMPNO) WHEN MATCHED THEN UPDATE SET ENAME=EMP.ENAME,SAL=EMP.SAL,COMM=EMP.COMM,DEPTNO=EMP.DEPTNO,JOB=EMP.JOB,MGR=EMP.MGR,HIREDATE=EMP.HIREDATE WHEN NOT MATCHED THEN INSERT(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (EMP.EMPNO,EMP.ENAME,EMP.JOB,EMP.MGR,EMP.HIREDATE,EMP.SAL,EMP.COMM,EMP.DEPTNO);	

SAVEPOINT

1.SAVEPOINT A;
  SAVEPOINT B;
  SAVEPOINT C;
  ROLLBACK TO B;-THE DATE WHICH IS INSERTED TILL B WILL KE KEPT REST DELETED EX SAVEPOINT C;
  
GRANT OR REVOKE
GRANT ALL ON EMP_DUAL TO SYS;
GRANT SELECT,UPDATE ON EMP_DUAL TO SYS;
REVOKE ALL ON EMP_DUAL FROM SYS;